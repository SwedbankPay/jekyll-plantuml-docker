# coding: utf-8
require "jekyll"
require "html-proofer"
require "open3"

def verify(site_dir: "_site")
  options = {
    :assume_extension => true,
    :check_html => true,
    :enforce_https => true,
    :only_4xx => true,
    :check_unrendered_link => true,
  }
  HTMLProofer.check_directory(site_dir, options).run
end

# Test generated output has valid HTML and links.
task :test do
  image_name = ENV.fetch("IMAGE_NAME", "swedbankpay/jekyll-plantuml")
  image_tag = ENV.fetch("IMAGE_TAG", "latest")

  # Spin up docker
  cmd = %Q(
        docker run \
        --detach \
        --publish 4000:4000 \
        --env JEKYLL_ENV=production \
        --tty \
        --volume "#{Dir.pwd}:/srv/jekyll" \
        "#{image_name}:#{image_tag}"
        )

  stdout, stderr, _ = Open3.capture3(cmd)

  unless stderr.empty?
    raise stderr
  end

  begin
    log_stdout, log_stdrr, _ = Open3.capture3("docker logs #{stdout}")

    unless log_stdrr.empty?
      raise stderr
    end

    timout_counter = 0
    # Scan docker log until we find that the server is running
    while log_stdrr.empty? && !log_stdout.include?("Server running") && timout_counter < 300
      log_stdout, log_stdrr, _ = Open3.capture3("docker logs #{stdout}")
      sleep 1
      timout_counter += 1
    end

    site_dir = File.join(Dir.pwd, "_site")

    # Very practical for debug purposes to have the Docker log
    puts log_stdout

    puts "Checking files in #{site_dir}:"
    puts Dir.entries(site_dir)

    verify(site_dir)
  ensure
    Open3.capture3("docker stop #{stdout}")
  end
end

task :verify_output do
  verify
end

task :default => ["test"]
task :verify => ["verify_output"]
